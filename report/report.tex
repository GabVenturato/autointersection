\documentclass{memoir}
\usepackage{hyperref}
\usepackage{graphicx}
\graphicspath{ {figures/} }

\setcounter{secnumdepth}{3}

\title{Distributed Systems:\\Crossing Intersection with Autonomous Vehicles}

\author{Antonio Toncetti\\Gabriele Venturato\\\\DMIF, University of Udine, Italy}

\date{%Version 0.1, 
	\today}

\begin{document}


%\begin{titlingpage}
\maketitle
\begin{abstract}
The aim of this project is to provide an implemented solution to the problem of autonomous vehicles crossing an intersection.
Although the solution relies on some simplifications, it can be further elaborated to work in a real-case scenario.

The solution proposed in this report is meant to be more general and as modular as possible, in order for it to be possibly extended in a concrete situation.
\end{abstract}
%\end{titlingpage}

\chapter{Introduction}\label{ch:intro}

The problem to solve is one in which some autonomous vehicles have to cross an intersection without getting involved into road accidents. 

The idea is to solve the problem for a generic intersection. Autonomous vehicles can not rely on a central server, they have to cooperate with each other to cross the intersection by taking decisions which ensure a \emph{fair} and \emph{safe} policy. In particular there are two components in the proposed solution: \emph{vehicles} and \emph{the environment}. The latter is necessary in this context in order to simulate sensors that are usually inside autonomous vehicles which allows them to interact with the environment (e.g. proximity sensors, GPS, cameras, etc\dots).
The system is \emph{fault tolerant}, but neither byzantine processes nor cybersecurity hazards are taken in consideration, for simplification purposes.

The report starts by analysing the project: Chapter~\ref{ch:analysis} is devoted to use cases, functional and non-functional requirements, and system assumptions too. Chapter~\ref{ch:project} contains the description of the general architecture, and specific algorithms.

Following chapters aim to describe implementation details, and validation w.r.t. requirements.



\chapter{Analysis}\label{ch:analysis}

This chapter describes in detail some fundamental assumptions about the system, as well as functional and non-functional requirements.

\section{Use cases}

The following subsections uses the following terminology:
\begin{itemize}
	\item AV or Autonomous Vehicle
	\item  a \emph{correct} AV is one that exhibits no failures at any
point in the execution under consideration.
	\item a \emph{failed} AV is one that has a software failure and remains failed during the execution under consideration.
\end{itemize}

Note that, in this chapter, \emph{environment} refers to a process that simulates the real environment that would otherwise be detected by the vehicle's sensors. Therefore, in a real-case scenario, the environment messages would be substituted by a sensor notification.

\subsection{Vehicle at an intersection}
\begin{description}
	\addtolength{\itemindent}{0.5cm}
	\item[Brief Description] \hfill \\
	An Autonomous Vehicle (AV) is approaching, entering and leaving a non empty intersection. The use case begins with the AV approaching an intersection and ends with the AV having left the intersection in the desired direction. 
	
	\item[Actors] \hfill
	\begin{itemize}
		\item Autonomous Vehicles (AVs)
		\item Environment
	\end{itemize}
	
	\item[Preconditions] \hfill
	\begin{itemize}
		\item There is one or more AVs at the intersection. 
		\item AVs can be both correct and failed.
		\item The AV approaching the intersection is correct.
		\item The AV knows the route to follow.
	\end{itemize}
	
	\item[Scenarios] \hfill
	\begin{description}
		\item Main scenario
		\begin{enumerate}
			\item The AV is travelling along a road leading to an intersection.
			\item The AV is approaching the intersection.
			\item The AV stops at the entrance to the intersection.
			\item The AV signals its intent to other AVs at the intersection.
			\item The AV agrees with other participants on how to solve the intersection.
			\item The AV initiates the turn procedure towards the desired exit.
			\item The AV is in the intersection travelling to an exit.
			\item The AV leaves the intersection through an exit.
			\item The AV signals that it has successfully left the intersection.
			\item The AV continues to travel along its path.
		\end{enumerate}
		\item Alternative scenario
		\begin{enumerate}
			\item 1, 2	The AV finds a correct AV in front and waits in queue.
			\item 1, 2, 6, 7	The AV finds a failed AV in front awaits for its removal.
		\end{enumerate}
	\end{description}

	\item[Postconditions] \hfill \\
	At any point in its journey the AV can become inactive due to a mechanical failure or a software failure.
\end{description}

\subsection{Vehicle mechanical failure}
\begin{description}
	\addtolength{\itemindent}{0.5cm}
	\item[Brief Description] \hfill \\
	An Autonomous Vehicle (AV) has a mechanical failure but the software is still working properly. The use case begins when the breakdown happens, and ends with the recovery of a normal situation.
	
	\item[Actors] \hfill
	\begin{itemize}
		\item Autonomous Vehicle (AV)
		\item Environment
	\end{itemize}
	
	\item[Preconditions] \hfill
	\begin{itemize}
		\item There are possibly other AVs in the intercept network.
		\item Other AVs can fail at any moment.
	\end{itemize}
	
	\item[Scenarios] \hfill
	\begin{description}
		\item Main scenario
		\begin{enumerate}
			\item The AV detects the mechanical breakdown.
			\item The faulty AV communicates its state to others in the network and to the environment.
			\item The faulty AV awaits for is removal.
			\item Before leaving, communicate the resolution to others (and the environment).
		\end{enumerate}
	\end{description}
	
	\item[Postconditions] \hfill \\
	The network does not contain the faulty AV.
\end{description}

\subsection{Vehicle software failure}
\begin{description}
	\addtolength{\itemindent}{0.5cm}
	\item[Brief Description] \hfill \\
	When an Autonomous Vehicle (AV) has a software failure. This implies a mechanical failure, because we assume that a software failure stops the AV. The use case begins with the fault having happened, and ends with the recovery of a normal situation.
	
	\item[Actors] \hfill
	\begin{itemize}
		\item Autonomous Vehicle (AV)
		\item Environment
	\end{itemize}
	
	\item[Preconditions] \hfill
	\begin{itemize}
		\item There is at least one failed AV.
		\item There are possibly other AVs in the intersection network.
		\item Other AVs can fail at any moment.
	\end{itemize}
	
	\item[Scenarios] \hfill
	\begin{description}
		\item Main scenario
		\begin{enumerate}
			\item Another AV in the network detects the failure.
			\item The AV that detected the failure communicates to other AVs in the network which AV has just failed.
			\item Everyone affected awaits for the failed AV to be removed.
			\item The environment communicates to the AV which detected the failure that the failed AV has been removed.
			\item The normal situation is restored.
		\end{enumerate}
		\item Alternative scenario
		\begin{enumerate}
			\item At 1 it can happen that there is no other AVs, in that case the failed AV stays in the intersection until someone comes to rescue it.
		\end{enumerate}
	\end{description}
	
	\item[Postconditions] \hfill \\
	The network does not contain the failed AV.
\end{description}

\section{Assumptions}

Some general considerations are here presented. First of all it is assumed a situation in which each autonomous vehicle knows its destination and the route it is going to travel, since we can assume that each AV has a GPS device on board.

Moreover it is assumed, for sake of simplicity, that all vehicles have the same dimension --- or better: that each vehicle can fit into a single position of the internal model used to represent the roads. Moreover, common physical quantities (like weight, speed, acceleration, etc\dots) are omitted. Instead, the autonomous vehicles move in unit steps governed by the internal model.
\newline

Further assumptions are:

\begin{itemize}
	\item \emph{Faults}: at any moment a failure can arise in vehicles --- software or mechanical. A mechanical failure does not compromise the software abilities, but a software failure implies a mechanical failure. So we can assume that if the software fails, the autonomous vehicle stops and goes in ``emergency mode''. It is also assumed that if a failure happens, it must be managed by removing the faulty vehicle with a tow truck (or something similar).
	\item \emph{Moves}: the path that a vehicle can take inside the intersection is predefined and known a priori. From each position there is a unique path to each destination, and no one can modify or choose a different path once decided. A visual representation of this assumption can be found in Figure~\ref{fig:intersection-graph}, in which green dots represent positions occupied while crossing, and light-blue dots are the destinations. Reversing is not allowed.
	\item \emph{Message Delivery}: each vehicle can communicate with its immediate neighbors, i.e. the vehicle in front, the one behind it, and if it is at the verge of the crossroads, it can communicate with the others at the verge, and with crossing vehicles. Therefore it is assumed that there exist an upper bound in the time required for message delivery between two vehicles. This is justified by the fact that all connection are almost direct, without routers or brokers that can cause bottle-necks or network congestion.
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[width=0.4\linewidth]{intersection_graph.pdf}
	\caption{Example of predefined movements that a vehicle can follow in crossing an intersection.}
	\label{fig:intersection-graph}
\end{figure}

\section{Functional requirements}
The solution provides two main modules: \emph{vehicle} and \emph{environment}. Also a \emph{vehicle generator} is provided, in order to test and validate the solution proposed.

\subsection{Vehicle}
Each vehicle holds an internal state at any moment. Moreover it:

\begin{itemize}
	\item knows its position and what happens around, through the environment (in a real context this is handled by sensors like GPS and proximity sensors): it can detect if there are other vehicles trying to cross the intersection or if there is a vehicle in front.
	\item when in a queue, it knows nothing else than its internal information and that it is taking part in a queue with someone in front and possibly behind.
	\item at the entrance to an intersection, it can connect with other vehicles (that are at the other entrances) willing to cross the intersection.
\end{itemize}
Therefore the main functions offered by this module are:

\begin{itemize}
	\item \texttt{initialize()} to initialise the vehicle by passing a route to follow and the environment (process) reference.
	\item \texttt{startup()} to start the vehicle.
	\item \texttt{stop()} to stop the vehicle.
	\item \texttt{cause\_mechanical\_failure()} and \texttt{cause\_software\_failure()}, to cause failures; these are useful in testing to simulate failures.
	\item \texttt{send\_message(To,Msg)} to communicate with other vehicles.
	\item \texttt{move()} to move one step forward.
	\item \texttt{check\_next\_position()} to check if the position it is willing to move is free.
\end{itemize}


\subsection{Environment}
The environment represents the vehicle ability to use its sensors. It knows the intersection shape and dimension; it knows the vehicle's positions; it provides vehicles with all the information they need to safely circulate within the environment.

The main functions offered by this module are:

\begin{itemize}
	\item \texttt{is\_position\_free(Pos)} to simulate proximity sensors; check if a specific position is free.
	\item \texttt{update\_position(Vehicle,OldPos,NewPos)} to update its internal state by moving the vehicle from the old position into the new one.
	\item \texttt{get\_route(StartPos,DestPos)} to simulate the GPS; a vehicle that is starting its journey asks the environment which is the route it has to travel.
	\item \texttt{get\_participants()} to simulate proximity sensors, cameras, and antennas; to obtain the identity of vehicles at the entrance to an intersection. 
\end{itemize}

\subsection{Generator}
The aim of the generator is to pseudo-randomly generate an amount of vehicles and start them to test the solution proposed. It offers a unique function \verb|generate([Prams])| used to manage the vehicle generation with some tunable parameters such as: how many vehicle it has to generate and the percentage of failures it has to cause.

\section{Non functional requirements}
The system does not handle byzantine processes and cybersecurity issues.

\begin{itemize}
	\item \emph{Safeness}: there can not be more than a vehicle in the same position at the same time;
	\item \emph{Liveness}: if a vehicle approaches the intersection and is willing to cross it, it will eventually cross it;
	\item \emph{Fairness}: if a vehicle approaches the intersection and is willing to cross it, there exists a bound to the waiting time;
	\item \emph{Fault Tolerant}: the system is tolerant to mechanical and software failures;
	\item \emph{Distributed}: there is no central server, vehicles have to coordinate each other.
\end{itemize}



\chapter{Project}\label{ch:project}
This chapter is devoted to the description of the general architecture, and specific algorithms.

\section{Logical architecture}
The solution relies on two main modules, and a secondary one for tests.

\begin{itemize}
	\item \emph{Vehicle}: composed of multiple components that communicate through an event manager and are coordinated by a coordinator. Each component is responsible for delivering a specific service (motion, communication, recognition). 
	
The process in charge of resolving the intersection crossing is spawned by the communication component and is represented as a finite state automaton. A graphical representation can be seen in Figure~\ref{fig:vehicle-automaton}. Each state represents a situation in which the vehicle can find itself. A vehicle is in the \emph{Init} state when it has just approached the intersection. It is in the \emph{Ready} state when it is at the verge and has identified the participants. It is in \emph{Election} when it is performing the election algorithm to choose who will be the one to cross. \emph{Crossing} when it is crossing the intersection, and \emph{Terminate} when it has finished the crossing. When a mechanical failure happens, it notifies the event to its neighbors and then terminates: a crash state is not needed.
	\item \emph{Environment}: represents the physical environment accessible through the autonomous vehicle's sensors.
	\item \emph{Vehicle Generator}: a module aimed to (pseudo-)randomly generate vehicles that approach the intersection, and it is used to test and validate the proposed solution.
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{vehicle_automaton.pdf}
	\caption{Vehicle as a finite state automaton.}
	\label{fig:vehicle-automaton}
\end{figure}

\section{Protocols and algorithms}
This section describes the algorithm to solve the core part of the project. Moreover, some peculiar situations are described with the help of sequence diagrams.

\subsection{Intersection Crossing Algorithm}\label{sec:intersection-crossing-algorithm}
Vehicles queue up along the roads leading to an intersection awaiting for their turn to cross. The first vehicle of a queue is the vehicle at the entrance to an intersection and we will call such vehicle a \emph{participant} of the intersection crossing algorithm.

Note that this algorithm can be applied to generic intersections just by changing the graph representation. Moreover, it trivially guarantees the \emph{fairness} and \emph{liveness} requirements (thus it is also \emph{deadlock-free}), thanks to its round robin characteristic.
\\\\
\noindent
The algorithm maintains the following invariant through execution:

\begin{itemize}
	\item one correct (i.e. without faults) vehicle per time can cross the intersection
	\item only the leader vehicle can cross the intersection
\end{itemize}
Algorithm description:
\begin{enumerate}
	\item The participants are willing to cross the intersection;
	\item They start a slightly modified version \footnote{In the canonical version of the Bully Algorithm, every participant is supposed to know other IDs a priori. The version used here does not rely on this assumption. Still, it guarantees the same outcome, even w.r.t. non functional requirements (safety and liveness).} of the Bully Algorithm to elect a leader: it terminates with the leader $L$, and the next leader $L'$, which is the first vehicle after him in a clockwise manner;
	\item $L$ begins to cross the intersection;
	\item After $L$ has successfully crossed the intersection, the participants are informed;
	\item $L'$ identifies the next leader $L''$ by choosing the first vehicle after him in a clockwise manner;
	\item The lead passes to $L'$ informing every participant that it is the new leader;
	\item The algorithm repeats from 3, where $L = L'$ and $L' = L''$.
\end{enumerate}
Additional details:
\begin{itemize}
	\item After the leader election, every participant knows who is the current leader, but only the leader knows who is the next one. This way if the current leader dies, a new election has to happen;
	\item Once the leader starts crossing, the vehicle behind it (if any) becomes a new participant and asks to join the algorithm. Only the leader answers, providing its identity.
	\item If a vehicle approaches an empty intersection it automatically elects itself as leader and starts crossing.
\end{itemize}
A leader election starts when new participants do not receive an answer from the current leader when asking to join the algorithm; or when the leader is gone (after completing the crossing, or due to a failure) and the remaining participants do not receive a message from the candidate communicating it is the new leader.

\subsubsection{Managing abnormal cases}\label{subsec:abnormal-cases}

The participants monitor the leader only. If the leader fails, everyone expects a message from the candidate, telling them it is the new leader. If this does not happen, a new election is started. Moreover:

\begin{itemize}
	\item If the leader fails, the vehicle in clockwise order after him becomes the new leader --- identifying also the next candidate leader --- and the algorithm restarts from 3.
	\item If the leader fails while crossing, a timeout $T$ is needed before it is removed from the intersection. Meanwhile a new election can start, and the new leader can start crossing, but it has to stop until the position gets liberated if the position in front is still occupied by the previous faulty leader.
	\item Some peculiar situations can happen when a new vehicle arrives at the intersection while the leader is gone and it is passing the lead to the candidate. If a new vehicle arrives at this unfortunate moment, it could receive no answers when asking who is the leader, and so it starts a new election. The risk is that the newly arrived vehicle becomes the leader, stealing the role to the candidate. This can lead to disastrous scenarios, in which more than a vehicle starts crossing. To avoid this, it is \emph{necessary} that, in case of a sudden election, a candidate receiving the role from the previous leader turns out to be the winner. Therefore no one can steal the lead role from anyone else. This is guaranteed with an appropriate implementation, described in the next chapter.
\end{itemize}

\subsection{Sequence Diagrams}
This section presents some sequence diagrams of relevant case situations.

\subsubsection{Normal execution of Intersection Crossing Algorithm}
The diagram in Figure~\ref{fig:seq-diag-crossing-intersection} represents the normal execution of the algorithm described above. It starts at the end of the Bully Algorithm, with the $AV_4$ communicating it is the leader. It is assumed that the intersection entrances are enumerated 1 to 4 in a clockwise order.

The leader crosses the intersection by asking the environment if the position in front is free, and continues to cross until it reaches its destination.

It is important to note that when the leader starts crossing, $AV_5$ --- which is the one following $AV_4$ in the queue --- moves forward. Then $AV_5$ is at the entrance of the intersection and can communicate with the other participants in order to compete for the crossing.

\begin{figure}
	\centering
	\includegraphics[width=\linewidth]{sequence_diagrams/crossing_intersection.pdf}
	\caption{Sequence diagram on a normal execution of the Intersection Crossing Algorithm described above.}
	\label{fig:seq-diag-crossing-intersection}
\end{figure}

\subsection{Dealing with AV failures}

When the leader dies because of a software failure, it can not promote the candidate. So a new election is needed. The situation is represented by the sequence diagram in Figure~\ref{fig:seq-diag-leader-sw-failure}

\begin{figure}
	\centering
	\includegraphics[width=\linewidth]{sequence_diagrams/leader_sw_failure.pdf}
	\caption{Sequence diagram representing a generic leader failure.}
	\label{fig:seq-diag-leader-sw-failure}
\end{figure}

The last situation in Figure~\ref{fig:seq-diag-candidate-failure} represents a failure of the candidate. When the leader finishes crossing, everyone waits a timeout $T$ for a message from the candidate. Since it is not alive, the timeout runs out, and a new election is started.

\begin{figure}
	\centering
	\includegraphics[width=\linewidth]{sequence_diagrams/candidate_failure.pdf}
	\caption{Sequence diagram of a candidate leader failure.}
	\label{fig:seq-diag-candidate-failure}
\end{figure}

\section{Physical architecture and deployment}
The architecture is quite simple, a graphical representation is displayed in Figure~\ref{fig:physical-architecture}. Each Autonomous Vehicle (AV) is a physical node. The Environment represents the world sensed by AVs, so it is on a separate node together with the vehicle generator. AVs can ask the environment for information, and they can communicate with their neighbors \footnote{For a definition of ``neighbors'', see in Chapter~\ref{ch:analysis}, in assumptions section. Where the message delivery assumption is described.}.

\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{physical_architecture.pdf}
	\caption{Physical architecture: Environment, Generator, and Autonomous Vehicles (AV).}
	\label{fig:physical-architecture}
\end{figure}


\chapter{Implementation}
The project is implemented in \href{https://www.erlang.org/}{Erlang}. We used as much as possible the OTPs offered by Erlang, since they speed up the development process and offer a solid and well-tested starting point.

\begin{figure}
	\centering
	\includegraphics[width=\linewidth]{config_graph.pdf}
	\caption{Graphical representation of the intersection graph contained in the configuration file and used to test the project. Nodes with name $R\_x$ represents roads. Details: start nodes are in green ($R\_1, R\_11, R\_21, R\_31$), destination node are in blue ($R\_10, R\_20, R\_30, R\_40$), intersection's internal nodes are in yellow ($I\_x$), intersection's entrance nodes in red ($IN\_x$) and intersection's exit nodes are in purple ($OUT\_x$). }
	\label{fig:config-graph}
\end{figure}

\section{Getting Started}
\subsection{Project Structure}
The project is organized in two different Erlang application: Vehicle and Environment. These can be found in the \verb|apps/| directory. The \verb|test/| directory contains some scripts to start the tests (described in Chapter~\ref{ch:validation}), and the vehicle generator module. Last but not least there is a \verb|docker/| directory and a \verb|Dockerfile| that are used to test the project with \href{https://www.docker.com/}{Docker} (described in Chapter~\ref{ch:validation}).

\subsection{Hands On}
A \emph{makefile} is provided in order to easily compile and clean the project, it provides a couple of demos too.

\noindent
\\
Make commands are described here:
\begin{itemize}
	\item \verb|make demo| performs a demo with erlang nodes generated on the local machine.
	\item \verb|make dockerdemo| performs a demo using Docker. Note that this commad will create some containers and a docker network on your machine. Later, if you want to clean up everything use \verb|make clean|.
	\item \verb|make| (which is the same as \verb|make apps|) compiles just the apps: environment and vehicle.
	\item \verb|make all| does what \verb|make| do, but it compiles also the generator module and gives the scripts (related to the generator) the execution permissions.
	\item \verb|make docker| does what \verb|make all| do, but it compiles also the Docker stuff.
	\item  \verb|make clean| removes all compiled files, log directories, and Docker stuff.
	\item  \verb|make distclean| removes the same as \verb|make clean|, plus it cleans also the report directory which contains latex files.
\end{itemize}

\section{Development Details: The Vehicle}

\subsection{Vehicle system}

The vehicle system architecture follows the event-based multi-agent architecture where the only source of events are vehicles (agents) and the environment.
Such architecture will greatly help in dealing with accidental complexity, changing requirements, security and performance.


Vehicles represent the main source of events, autonomously driving control towards their own goals, and producing internal events through their actions.
The environment and other vehicles model the external events. External events are captured by the vehicle's devices such as sensors, sonars, camera systems, receivers, transmitters, etc.

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{implementation_details/vehicle_high-level_architecture.pdf}
	\caption{Vehicle system architecture: Coordinator, Event Manager, and Components with Probes attached.}
	\label{fig:vehicle-architecture}
\end{figure}

The main elements of the architecture are the Coordinator, the Event Manager and various components that provide a specific service.
Vehicle components communicate by producing and receiving event notifications. All of the vehicle's functionality is split among the components: each component is responsible for delivering a specific service to the vehicle.

Components can be connected to sensors and other external devices in order to successfully deliver their functionality. External devices are referred to as probes.
The responsibility of probes is to collect external events from the environment or other vehicles and forward them to the component to which they are attached to.
External events received by components are translated into internal events.


The Coordinator listens for specific internal events in order to coordinate the components to reach the vehicle's goal.

\subsection{Architecture elements}

This subsection presents the architectural elements: Event Manager, Components and the Coordinator. Figure ~\ref{fig:erlang-point-of-view} shows the supervision tree implemented in Erlang with all the architectural elements.

\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{implementation_details/erlang_point-of-view.pdf}
	\caption{The implemented vehicle system supervision tree (Erlang point of view).}
	\label{fig:erlang-point-of-view}
\end{figure}

\subsubsection{Event Manager}

Components communicate by sending event notifications to the Event Manager.
Being not real messages, events have not a designed receiver: they are distributed by the Event Manager to Components that subscribed to that sort of events.

The Event Manager acts as a middleware, inverting the logic of program execution, where a component does not need to be aware of the existence of other components to provide its service and thus facilitates the addition of new features and components.

\subsubsection{Components}

Components are the only providers of functionality. Each component delivers a specific functionality to the system.

Components can be \textit{passive} or \textit{active}. Passive components do not generate internal events and their sole purpose is to listen to internal events and act accordingly. An example of a passive component is the Logging Component which listens for specific internal events and logs them onto a file.

Active components are components that generate internal events. For example the Communication Component, whose sole purpose is to handle communication between vehicles, is required by components that need Vehicle-to-Vehicle (V2V) communication services.
\\

\textit{Note that both active and passive components are capable of performing actions, changing their state and communicating with their devices except that passive components cannot interfere with the event flow of the vehicle because they don't generate internal events.}
\\

Components can have multiple devices attached (sensors, receivers, transmitters, etc.) in order to detect external events and provide their functionality.

Components help to address the issues of event aggregation and transformation by making event notifications meaningful at the level of interpretation required for making other components activities effective. They effectively act as event mediators (or, correlators), translating external events into meaningful internal events.


\textbf{Component Structure}
\\
\newline
The structure of a component consists of: 
\begin{itemize}
	\item component module (mandatory)
	\item event listener (optional)
\end{itemize}


\begin{description}
	\addtolength{\itemindent}{0.2cm}
	\item[The component module:] \hfill \\
The component module maintains all the logic related to the specific service it is built for, for example a component in charge of the navigation system deals with navigation related tasks only.

The component module can be connected to zero or more devices in order to provide its services, for example the navigation component can use a GPS device to gather geolocation data. 


When needed, components can spawn additional processes called Actions to perform more advanced and complicated tasks (Actions can also be used for enabling the selection of algorithms at runtime, effectively letting the algorithm vary independently from the component, a strategy pattern in OO terms).

	
	\item[The event Listener:] \hfill \\
A component module can have zero or more event listeners attached to the Event Manager. Event listeners are responsible for listening and forwarding internal events that are of interest to the component module.

A component that provides a service must have an event listener in order to receive requests from other components. Event listeners are event handlers in the Erlang terminology.
	
\end{description}

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{implementation_details/component_and_action.pdf}
	\caption{Part of the overall supervision tree showing components with their actions and their respective Action Supervisor}
	\label{fig:component-and-action}
\end{figure}

Figure ~\ref{fig:component-and-action} shows a component with its actions in the supervision tree. Actions are attached to a specific supervisor (the Action Supervisor) which is unique for each component.
\\

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{implementation_details/components_event_listeners.pdf}
	\caption{Components with Event Listeners registered on the Event Manager}
	\label{fig:component-event-listeners}
\end{figure}


Figure ~\ref{fig:component-event-listeners} shows how event listeners are attached to components and registered on the Event Manager.
Note that Component4 doesn't have any event listener, which is a perfectly valid situation.

\subsubsection{Coordinator}

The Coordinator represents the logic and reasoning of the system, coordinating the various components in order to achieve the vehicle’s goals.

The Coordinator listens for internal events of interest by registering event listeners on the Event Manager (just like components do).
Specific internal events trigger the Coordinator's actions which, in turn, produce new internal events addressed to specific components. 

This behaviour of recognising specific events and addressing specific components is what drives the vehicle towards its goals.

\subsubsection{The general flow of events}

Once the vehicle has been initialized and the startup message received, the vehicle can start to move. 
\\

(1)The Coordinator starts by asking the Recognition Component about the position type it is currently on. 
\\

There can be 2 basic position types (although the implementation provides significantly more) a \textit{free} position and a \textit{stop} position.

A \textit{free} position is any position onto which the vehicle is free to advance (for example, it is on a public road), where as a \textit{stop} position is a position that requires the vehicle to stop and resolve the situation (for example, an intersection entrance, an obstacle on the road, a 
car accident in front, etc).
\\

The Recognition Component utilises, for example, a camera system to detect the position type and returns an answer to the Coordinator.
\\

If the answer is \textit{free}, the Coordinator requests the Motion Component to check the position in front whether the vehicle is safe to advance.
If the answer is \textit{stop} the vehicle has to stop and resolve the problem. For the sake of simplicity (and, for the scope of this project) we assume that a position has type \textit{stop} if the vehicle is at the entrance to an intersection.
\\

 (2)Suppose that the Recognition Component's answer was \textit{free}, the Coordinator requests the Motion Component to verify the position in front. The Motion Component uses a proximity sensor to check whether the position in front is clear or occupied. An answer is provided to the Coordinator.
\\

If the answer is \textit{clear}, the vehicle advances in the next position. If the answer is \textit{occupied} the vehicle has to realise what is in front. For the scope of this project, we assume that only vehicles can be on the road. Therefore the vehicle tries to communicate with the vehicle in front, in order to check its health. 
\\

Suppose that the answer is \textit{occupied}. The Coordinator requests the Communication Component to contact the vehicle in front.
\\

The Communication Component can use, for example, a Bluetooth or a Wifi device to communicate with the vehicle in front (for example, send a broadcast with a message: "Who is at position X?"). The vehicle in front can either respond to the call, or, if it has software crashed, not respond at all. An answer is provided to the Coordinator.
\\

The Coordinator can either receive that the vehicle in front is \textit{up} (software is running correctly and the vehicle is waiting in a queue) or  \textit{down} (the vehicle in front has software crashed). If the vehicle in front is \textit{up}, the vehicle awaits in queue for the vehicle in front to move. If the vehicle in front is \textit{down} the vehicle calls a tow truck to remove the vehicle in front and awaits its removal.
In either cases, after a period of waiting, the vehicle moves in the position in front and the algorithm starts from (1).
\\

Returning to the step when the Coordinator requested the position type. If the Recognition Component’s answer is \textit{stop}, the vehicle is at the entrance to an intersection (for the reasons stated above) and has to stop to resolve the intersection crossing with vehicles at the other entrances in order to avoid potential collisions.
\\

The Coordinator uses the Communication Component in order to solve the intersection. The Communication Component contacts the intersection participants (vehicles at the entrances) and starts the intersection coordination (described in the next section). Once the vehicle is clear to move in the intersection, a notification is made to the Coordinator that the current position is \textit{free} and the algorithm takes on from (2).

\subsection{Intersection Coordination}
This module is the core of the intersection crossing problem and implements the algorithm described in Section~\ref{sec:intersection-crossing-algorithm}. This module is an OTP \verb|gen_statem|.

The main idea is to use as ID the pair \verb|(waiting_counter, nonce)|, where the nonce is a unique code for each vehicle (the Erlang node name), and a waiting counter which is zero when a vehicle approaches the intersection and increases by one for each \verb|crossed| message it receives, i.e. every time the leader crosses, the participants increase their counters. This way, every time an election is performed, the priority goes to the vehicles that waited longer. 

Moreover, is important to guarantee that no one steals the leader title to a candidate who received the promotion from the previous leader --- as specified in Subsection~\ref{subsec:abnormal-cases}. To do so, when a leader passes the lead to the candidate, the candidate sets its waiting counter to $N$, where we define $N$ as the number of intersection entrances. This guarantees what stated before, because no one can wait more than $N$, or better: every vehicle waiting counter reach at most $N - 1$. So, if an election is started, the candidate wins for sure. Setting the counter to less than this can lead to problems.

The last important part is that since no one knows others IDs, it is necessary to exchange that information while performing the election. The algorithm is implemented as follows:

\begin{itemize}
	\item to start the election send an election message with my ID, and wait for answers;
	\item if an answer is received, this means there exists someone with a higher ID and I have to wait for the coordinator message;
	\item if an election message is received, check the ID inside and compare it with mine. If the ID received is higher wait for a coordinator message, otherwise forward the election message with my ID to all participants and wait for answers;
	\item if I don't receive an answer, I can conclude that I have the maximum ID, therefore I am the leader and I have send the coordinator message.
\end{itemize}

Some timeouts are necessary to implement this idea. All the details are found in the code.

\section{Development Details: Environment, Vehicle Generator and Vehicle log files}
The Environment is an application that uses the OTP \verb|gen_server| behaviour and acts as a substitute of the vehicle sensors. It provides mainly the functions described in the functional requirements analysis.

The intersection graph is provided in a configuration file inside the \verb|config/| directory. The syntax is trivial. It is easy to build a different graph from the configuration file provided. Note that validation is not performed on the graph structure, so it is up to the developer to provide a correct configuration file.

The \emph{digraph} Erlang module is used to manage the graph. In particular the route from the starting position to the destination is the shortest path between the two nodes in the graph.

\bigskip
The generator is a simple OTP \verb|gen_server|, which offers only the function \verb|start()|, with different tunable parameters. Details of this module are described in the next chapter.

\bigskip
Vehicles generate log files inside the \verb|log/| directory. Logs are related to internal events and are categorised in 5 levels: Error, Warning, Info, Debug and Verbose. Log levels are used for text formatting. 


\chapter{Validation}\label{ch:validation}
The validation part consisted in three main phases. First of all the project was tested with few vehicles generated singularly into different shells, with Erlang nodes created on local machine. After the initial validation, manually simulating peculiar situations took place (software and mechanical failures, vehicles arrival at specific times, \dots), the software has undergone numerous tests with the help of the vehicle generator described in the previous chapter, all tests were performed on nodes locally. Finally, with the help of Docker, we tested the project with containers locally in a virtual network in order to simulate a real-case scenario where each vehicle is an independent system.

The project has been tested on Fedora 30 with Erlang/OTP 21, and on Ubuntu 18.04 LTS with Erlang/OTP 22.

After carefully planning, developing and testing the system, we are confident of providing a reliable and sound solution. Next sections describe how to reproduce the tests. All the scripts provided have been tested only on cited above operative systems, same results are not guaranteed on Mac OS or Windows.

When performing the tests it is necessary to have in mind the graph of the intersection presented in Figure~\ref{fig:config-graph}. Moreover, regarding the test with the generator and docker, the scripts will not exit at the end of the simulation because we do not know when will the vehicles terminate their route, but that can easily check if for about a minute nothing is printed in the log files (at \verb|docker_log/|), then the simulation is over, and you can kill the script with \verb|ctrl+C| and then \verb|(a)bort|.

\section{Simple Tests}
To use the code proposed here it is necessary to execute \texttt{make all}. Some scripts are provided in the direcotry \texttt{test/}. Note that it is important to execute the scripts provided from the project root.

First of all it is necessary to start the environment. To do it open a shell and run:
\begin{verbatim}
./test/start_environment.sh
\end{verbatim}
You should se now an Erlang shell with the message ``Env started!''.

Now it is time to create vehicles: pretty easy, open another shell and run:
\begin{verbatim}
./test/start_vehicle.sh 1 R_1 R_30
\end{verbatim}
Where, the first parameter is the index of the vehicle to generate --- note that if you insert $x$ the erlang node will be \verb|v|$x$\verb|@hostname|. The second and the third parameters are the start position, and the destination position, chosen from the graph in Figure~\ref{fig:config-graph}. One can also start a vehicle from other positions chosen from $R_x$ or $IN_x$, to test different situations.

You can see that every vehicle shell prints what the vehicle is doing, more information can be found in the vehicle logs inside the \texttt{log/} directory.

\section{Vehicle Generator}
To use the code presented here it is necessary to execute \texttt{make all}. To start the vehicle generator the script inside the \texttt{test/} directory can be used as follows:
\begin{verbatim}
./test/start_generator.sh <vehicle number> <fail ratio> \
	[relaive sw fail ratio] [max fail timeout (ms)]
\end{verbatim}
for example you can try:
\begin{verbatim}
./test/start_generator.sh 10 0.2 0.5 20000
\end{verbatim}
Where:
\begin{itemize}
	\item \verb|<vehicle number>| is mandatory and represents the number of vehicles that will be generated.
	\item \verb|<fail ratio>| is mandatory and represents the percentage (expressed as a number $0 \le x \le 1$) of failures that will be generated.
	\item \verb|[relaive sw fail ratio]| is optional and represents the ratio of software failures caused by the generator. (e.g. if set to $0.5$, half of the faults will be software and the other half will be mechanical).
	\item \verb|[max fail timeout (ms)]| represent the maximum time in milliseconds within which the fault will be caused, considering the moment when the vehicle starts. (e.g. if set to $20000$, the vehicle can fail after a maximum of $20s$ from its start).
\end{itemize}
To stop the execution press \verb|ctrl+C| and then \verb|(a)bort|. The information is all printed in the same shell, so it is less clear as what is happening, but the logs for each vehicle can be found in the \verb|log/| directory.

\section{Docker}
To use the code presented here it is necessary to execute \texttt{make docker}. Note that in order to run the tests proposed here it is required to have docker installed and configured properly. Some containers, and a network, will be created. The \verb|docker/| directory provides some scripts to easily run the tests and also to stop and clean the local machine from the containers and the network generated.

The command to run is:
\begin{verbatim}
./docker/start_docker.sh <vehicle number> <fail ratio> \
[relaive sw fail ratio] [max fail timeout (ms)]
\end{verbatim}
for example you can try:
\begin{verbatim}
./docker/start_docker.sh 10 0.2 0.5 20000
\end{verbatim}
Where the parameters are the same of the vehicle generator described in the previous section.
Note that in the shell you will see only messages printed from the generator. To see what is happening with the vehicles you can look at the \verb|docker_log/| directory, where all vehicles logs are generated. Furthermore, root permission to delete the \verb|docker_log/| directory could be required, because the files are generated by root user inside the containers, so the proprietary user is still root.
After stopping the simulation, everything can be cleaned with:
\begin{verbatim}
./docker/clean_docker.sh
\end{verbatim}

\chapter{Conclusions}
The proposed solution focuses on a very simplified version of what a real solution could be. In particular the aim was to produce a core solution which satisfies the requirements but also does not contain more than the necessary assumptions, and, in particular, that does not rely on non realistic ideas that can lead future development to a blind spot.

\section{Partial implementation and future work}
Some improvements that can be pursued starting from our solution are provided here. Some of them are easier than others, but due to lack of time we have not managed to deepen them:
\begin{itemize}
	\item Try different intersection graphs;
	\item Centralise some configuration parameters in such a way the solution can be tuned without recompiling;
	\item Exploit code change feature offered by Erlang;
	\item Develop a graphical interface of the environment to better understand how vehicles are moving;
	\item Add vehicles with priorities, e.g. emergency vehicles;
	\item Dynamically modify paths inside the crossroad if some position becomes unavailable;
	\item Use a different implementation for the Event Manager (currently implemented with the default Erlang gen\_event) that is capable of running each event handler on a separate process and can route event notifications only to handlers listening for that event.
	\item Let more than one vehicle per time cross the intersection, maybe with an interface to a planner in order to find the best route (exploiting epistemic planning could be an interesting option).
\end{itemize}

\end{document}