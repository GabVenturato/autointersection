\documentclass{memoir}
\usepackage{hyperref}
\usepackage{graphicx}
\graphicspath{ {figures/} }

\setcounter{secnumdepth}{3}

\title{Distributed Systems:\\Crossing Intersection with Autonomous Vehicles}

\author{Antonio Toncetti\\Gabriele Venturato\\\\DMIF, University of Udine, Italy}

\date{%Version 0.1, 
	\today}

\begin{document}


%\begin{titlingpage}
\maketitle
\begin{abstract}
The aim of this project is to provide an implemented solution to the problem of autonomous vehicles crossing an intersection.
Although the solution relies on some simplifications, it can be further elaborated to work in a real-case scenario.

The solution proposed in this report is meant to be more general and as modular as possible, in order for it to be possibly extended in a concrete situation.
\end{abstract}
%\end{titlingpage}

\chapter{Introduction}\label{ch:intro}

The problem to solve is the one in which some autonomous vehicles have to cross an intersection without being involved in road accidents. 

The idea is to solve the problem for a generic intersection. The autonomous vehicles can not rely on a central server, they have to cooperate with each other to cross the intersection by taking decisions which ensure a \emph{fair} and \emph{safe} policy. In particular there are two components in the proposed solution: vehicles and the environment. The latter is necessary in this context in order to simulate sensors that are usually inside autonomous vehicles which allows them to interact with the environment (e.g. proximity sensors, GPS, cameras, etc\dots).
The system is \emph{fault tolerant}, but neither byzantine processes nor cybersecurity hazards are taken in consideration, for simplification purpose.

The report starts by analysing the project: Chapter~\ref{ch:analysis} is devoted to use cases, functional and non-functional requirements, and system assumptions too. Chapter~\ref{ch:project} contains the description of the general architecture, and specific algorithms.

Following chapters aim to describe details of the implementation, and validation w.r.t. requirements.



\chapter{Analysis}\label{ch:analysis}

This chapter describes in detail some fundamental assumptions about the system, as well as functional and non-functional requirements.

\section{Use cases}

\subsection{Vehicle at an intersection}
\begin{description}
	\addtolength{\itemindent}{0.5cm}
	\item[Brief Description] \hfill \\
	An Autonomous Vehicle (AV) is approaching, entering and leaving a non empty intersection. The use case begins with the AV approaching an intersection and ends with the AV having left the intersection in the desired direction. 
	
	\item[Actors] \hfill
	\begin{itemize}
		\item Autonomous Vehicles (AVs)
		\item Environment
	\end{itemize}
	
	\item[Preconditions] \hfill
	\begin{itemize}
		\item There is more than one AV at the intersection. 
		\item AVs can be both active and inactive.
		\item The AV approaching the intersection is active.
		\item The AV knows the direction (exit) to take.
	\end{itemize}
	
	\item[Scenarios] \hfill
	\begin{description}
		\item Main scenario
		\begin{enumerate}
			\item The AV is travelling along a road leading to an intersection.
			\item The AV is approaching the intersection.
			\item The AV stops at the entrance to the intersection.
			\item The AV signals its intent to other AVs at the intersection.
			\item The AV agrees with the other participants on how to solve the intersection.
			\item The AV initiates the turn procedure towards the desired exit.
			\item The AV is in the intersection travelling to an exit.
			\item The AV leaves the intersection through an exit.
			\item The AV signals that it has successfully left the intersection.
			\item The AV continues to travel along its path.
		\end{enumerate}
		\item Alternative scenario
		\begin{enumerate}
			\item 1, 2	The AV finds an active AV in front and gets in the queue.
			\item 1, 2	The AV finds a faulty AV in front and overtakes him.
			\item 6. 7	The AV finds a faulty AV and awaits for its removal.
		\end{enumerate}
	\end{description}

	\item[Postconditions] \hfill \\
	At any point in its journey the AV can become inactive due to a mechanical failure or  a software failure.
\end{description}

\subsection{Vehicle mechanical failure}
\begin{description}
	\addtolength{\itemindent}{0.5cm}
	\item[Brief Description] \hfill \\
	When an Autonomous Vehicle (AV) has a mechanical failure but the software is still working properly. The use case begins when the failure happens, and ends with the recovery of a normal situation.
	
	\item[Actors] \hfill
	\begin{itemize}
		\item Autonomous Vehicle (AV)
		\item Environment
	\end{itemize}
	
	\item[Preconditions] \hfill
	\begin{itemize}
		\item There is at least one AV with a mechanical fault.
		\item There are possibly other AVs in the intercept network.
		\item Any other AV can fail at any moment.
	\end{itemize}
	
	\item[Scenarios] \hfill
	\begin{description}
		\item Main scenario
		\begin{enumerate}
			\item The AV detects the mechanical fault.
			\item The faulty AV communicates its state to the others in the network and to the environment.
			\item Faulty AV awaits until it is removed.
			\item Before leaving, communicate to the others (and the environment) the resolution.
		\end{enumerate}
	\end{description}
	
	\item[Postconditions] \hfill \\
	The network does not contain the faulty AV anymore.
\end{description}

\subsection{Vehicle software failure}
\begin{description}
	\addtolength{\itemindent}{0.5cm}
	\item[Brief Description] \hfill \\
	When an Autonomous Vehicle (AV) has a software failure. This implies a mechanical failure, because we assume that a software failure stops the AV. The use case begins with the fault having happened, and ends with the recovery of a normal situation.
	
	\item[Actors] \hfill
	\begin{itemize}
		\item Autonomous Vehicle (AV)
		\item Environment
	\end{itemize}
	
	\item[Preconditions] \hfill
	\begin{itemize}
		\item There is at least one AV with a software fault.
		\item There are possibly other AVs in the intersection network.
		\item Any other AV can fail at any moment.
	\end{itemize}
	
	\item[Scenarios] \hfill
	\begin{description}
		\item Main scenario
		\begin{enumerate}
			\item One of the other AVs in the network detects the fault.
			\item The AV which detects the fault communicates to others in the network which AV has just faulted.
			\item Everyone awaits for the faulty AV to be removed.
			\item The Environment communicates to the AVs in the network the occured removal.
		\end{enumerate}
		\item Alternative scenario
		\begin{enumerate}
			\item On 1 can happen that there is no other AVs, in that case the faulted AV stays into the intersection until someone comes to the rescue.
		\end{enumerate}
	\end{description}
	
	\item[Postconditions] \hfill \\
	The network does not contain the faulty AV anymore.
\end{description}

\section{Assumptions}

Some general considerations are here presented. First of all it is assumed a situation in which each autonomous vehicle knows its destination and the roads it is going to travel, since we can assume that each autonomous vehicle has a GPS device on board.

Moreover it is assumed, for sake of simplicity, that all vehicles have the same dimension --- or better: that each vehicle can fit into a single position of the internal model used to represent the roads. Moreover, common physical quantities (like weight, speed, acceleration, etc\dots) are omitted. Instead, the autonomous vehicles move in unit steps governed by the internal model.
\newline

Further assumptions are:

\begin{itemize}
	\item \emph{Faults}: at any moment a failure can arise in vehicles --- software or mechanical. A mechanical failure does not compromise the software abilities, but a software failure implies a mechanical failure. So we can assume that if the software fails, the autonomous vehicle stops and goes in ``emergency mode''. It is also assumed that if a crash happens, it must be managed by removing the faulty vehicle with a tow truck (or something similar).
	\item \emph{Moves}: the path that a vehicle can take inside the interception is predefined and known a priori. From each position there is a unique path to each destination, and no one can modify or choose a different path once decided. A visual representation of this assumption can be found in Figure~\ref{fig:intersection-graph}, in which green dots represent positions occupied while crossing, and light-blue dots are the destinations. Once a vehicle reaches its destination, it is considered ``satisfied'', and can not fail anymore, it can only move forward on its own way. Reversing is not allowed.
	\item \emph{Message Delivery}: each vehicle can communicate with its immediate neighbors, i.e. the vehicle in front, the one behind it, and if it is at the verge of the crossroads, it can communicate with the others at the verge, and with crossing vehicles. Therefore it's assumed that there exist an upper bound time in message passing between two vehicles. This is justified by the fact that all connection are almost direct, without routers or broker that can cause bottle-necks or network congestion.
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[width=0.4\linewidth]{intersection_graph.pdf}
	\caption{Example of predefined movements that a vehicle can follow in crossing an intersection.}
	\label{fig:intersection-graph}
\end{figure}

\section{Functional requirements}
The solution provides two main modules: \emph{vehicle} and \emph{environment}. Also a \emph{vehicle generator} is provided, in order to test and validate the solution proposed.

\subsection{Vehicle}
Each vehicle has an internal state at any moment. Moreover it:

\begin{itemize}
	\item knows its position and what happens around, through the environment (in a real context this is handled by sensors like GPS and proximity sensors): it can detect if there are other vehicles trying to cross, or if there is a vehicle in front or behind it.
	\item communicates with its neighbors by sharing: the direction it wants to travel, its internal state, the next position he is about to reach.
	\item if it is in the queue, it knows nothing else than its internal information and that it is taking part in a queue with someone before and possibly behind. It can communicate only with these two.
	\item if it is at the head of the queue, it can connect with other vehicles (that are at the head of other queues) that are crossing the intersection.
\end{itemize}
So, main functions offered by this module are:

\begin{itemize}
	\item \texttt{startup()} to start the vehicle.
	\item \texttt{stop()} to stop the vehicle.
	\item \texttt{cause\_mechanical\_failure()} and \texttt{cause\_software\_failure()}, to cause failures; these are useful to test simulating failures.
	\item \texttt{send\_message(To,Msg)} to communicate with other vehicles.
	\item \texttt{move()} to move one step forward.
	\item \texttt{check\_next\_position()} to check if the position it is willing to move is free.
\end{itemize}


\subsection{Environment}
The environment represent the vehicle ability to use its sensors. It knows the intersection shape and dimension; it knows vehicles approaching the crossroads and the ones in the queues; it provides vehicles with all the information they need to safely circulate within the environment.

So, main functions offered by this module are:

\begin{itemize}
	\item \texttt{is\_position\_free(Pos)} to simulate proximity sensors; check if a specific position is free.
	\item \texttt{update\_position(Vehicle,OldPos,NewPos)} to update its internal state moving the vehicle from the old position into the new one.
	\item \texttt{get\_route(StartPos,DestPos)} to simulate the GPS; a vehicle that is going to start its journey ask the environment which is the route it has to travel.
	\item \texttt{get\_participants()} to simulate proximity sensors, cameras, and antennas; to ask the identity of vehicles at the verge of the intersection. 
\end{itemize}

\section{Non functional requirements}
The system does not handle byzantine processes nor cybersecurity issues.

\begin{itemize}
	\item \emph{Safeness}: there can not be more than a vehicle in the same position at the same time;
	\item \emph{Liveness}: if a vehicle approaches the intersection and is waiting to cross it, eventually it will cross it;
	\item \emph{Fairness}: if a vehicle approaches the intersection and is waiting to cross it, there exists a bound to the waiting time;
	\item \emph{Fault Tolerant}: the system is tolerant to mechanical and software failures;
	\item \emph{Distributed}: there is no central server, vehicles have to coordinate each other.
\end{itemize}



\chapter{Project}\label{ch:project}
This chapter is devoted to the description of the general architecture, and specific algorithms.

\section{Logical architecture}
The solution relies on two main modules, and a secondary one for tests.

\begin{itemize}
	\item \emph{Vehicle}: it is represented as a finite state automaton. A graphical representation can be seen in Figure~\ref{fig:vehicle-automaton}. Each state represents a situation in which the vehicle can find itself. A vehicle is in the \emph{Init} state when it has just approached the intersection. It is in the \emph{Ready} state when it is at the verge and has identified the participants. It is in \emph{Election} when it is performing the election algorithm to choose who will be the one to cross. \emph{Crossing} when it is crossing the interception, and \emph{Terminate} when it has finished the crossing. When a mechanical failure happens, it notifies the event to its neighbors and then terminate; so a crash state is not needed.
	\item \emph{Environment}: it represents the physical environment accessible through autonomous vehicle sensors.
	\item \emph{Vehicle Generator}: it is a module aimed to (pseudo-)randomly generate vehicles that approach the intersection, and it is used to test and validate the solution proposed.
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{vehicle_automaton.pdf}
	\caption{Vehicle as a finite state automaton.}
	\label{fig:vehicle-automaton}
\end{figure}

\section{Protocols and algorithms}
This section describes the algorithm to solve the core part of the project. Moreover, some peculiar situation sequence diagrams are presented.

\subsection{Intersection Crossing Algorithm}
Vehicles queue up along the roads leading to an intersection awaiting for their turn to cross. The first vehicle of a queue is the vehicle at the verge of entering the intersection and we will call such vehicle a \emph{participant} of the intersection crossing algorithm.

Note that this algorithm applies to generic intersections, just by adapting the representing graph. Moreover, it trivially guarantees the \emph{fairness} and \emph{liveness} requirements (thus it is also \emph{deadlock-free}), thanks to its round robin characteristic.
\\\\
\noindent
The algorithm maintains the following invariant through execution:

\begin{itemize}
	\item one working (i.e. without faults) vehicle per time can be crossing the intersection
	\item only the leader vehicle can cross the intersection
\end{itemize}
Algorithm description:
\begin{enumerate}
	\item The participants (first vehicles in their respective queues) are willing to cross the intersection;
	\item They start a slightly modified version \footnote{In the canonical version of the Bully Algorithm, every participant is supposed to know other IDs a priori. The version used here does not rely on this assumption. Still, it guarantees the same outcome, even w.r.t. non functional requirements (safety and liveness).} of the Bully Algorithm to elect a leader: it terminates with the leader $L$, and the next leader $L'$, which is the first vehicle after him in a clockwise manner;
	\item $L$ begins to cross the intersection;
	\item After $L$ has successfully crossed the intersection, the participants are informed;
	\item $L'$ identifies the next leader $L''$ by choosing the first vehicle after him in a clockwise manner;
	\item The lead passes to $L'$ informing every participant that it's the new leader;
	\item The algorithm repeats from 3, where $L = L'$ and $L' = L''$.
\end{enumerate}
Additional details:
\begin{itemize}
	\item After the leader election, every participant knows who is the current leader, but only the leader knows who is the next one. In this way if the leader dies, it is necessary to perform a new election;
	\item Once the leader starts crossing, the vehicle behind it (if any) becomes a new participant and asks to join the algorithm. Only the leader answers, providing its identity.
	\item If a vehicle approaches an empty intersection it automatically elect itself as leader and starts the crossing.
\end{itemize}
A leader election starts only when new participants do not receive an answer when asking to join the algorithm; or when, after the leader is gone (after completing the crossing, or due to a failure), remaining participants does not receive the message from the candidate, communicating it is the new leader.

\subsubsection{Managing abnormal cases}

All participants monitor only the leader, if it fails, everyone is expecting a message from the candidate, telling it is the new leader. If this not happens, a new election is started. Moreover:

\begin{itemize}
	\item If the leader fails, the vehicle in clockwise order after him becomes the new leader --- identifying also the next candidate leader --- and the algorithm restarts from 3.
	\item If the leader fails while crossing, a timeout $T$ is needed before it is removed from the intersection. Meanwhile a new election can start, and the new leader can start crossing, but it has to stop if the position in front of him is still occupied from the previous faulty leader, until the position has been freed.
	\item Some peculiar situations can happen for example when a new vehicle arrives at the interception while the leader is gone and it is passing the leading to the candidate. It the new vehicle arrives at an unfortunate moment, it could receive no answers when asking who is the leader, and so starting a new election. The risk is that the candidate can become leader, and after a while someone else can win the election, stealing its role of leader. This can lead to disastrous scenarios, in which more than a vehicle start crossing. To avoid this, it is \emph{necessary} that a candidate receiving the role from the previous leader, in case of a sudden election, it turns out to be the winner. So, no one can steal the leading from anyone else. This is guaranteed with an appropriate implementation, described in the next chapter.
\end{itemize}

\subsection{Sequence Diagrams}
This section presents some sequence diagrams of relevant case situations.

\subsubsection{Normal execution of Intersection Crossing Algorithm}
The diagram in Figure~\ref{fig:seq-diag-crossing-intersection} represent the normal execution of the algorithm described above. It starts at the end of the Bully Algorithm, with the $AV_4$ communicating it is the leader. It is assumed the queues are enumerated from 1 to 4 in clockwise order.

The leader crosses the intersection by asking the environment if the position in front of it is free, and continues to cross until it reaches its destination.

It is important to note that when the leader starts crossing, $AV_5$ --- which is the one following $AV_4$ in the queue --- moves forward. Then $AV_5$ is at the verge of the intersection and can communicate with the other participants in order to compete for the crossing.

\begin{figure}
	\centering
	\includegraphics[width=\linewidth]{sequence_diagrams/crossing_intersection.pdf}
	\caption{Sequence diagram on a normal execution of the Intersection Crossing Algorithm described above.}
	\label{fig:seq-diag-crossing-intersection}
\end{figure}

\subsection{Dealing with AV failures}

When the leader dies because of a software failure, it can not promote the candidate. So a new election is needed. The situation is represented by the sequence diagram in Figure~\ref{fig:seq-diag-leader-sw-failure}

\begin{figure}
	\centering
	\includegraphics[width=\linewidth]{sequence_diagrams/leader_sw_failure.pdf}
	\caption{Sequence diagram representing a generic leader failure.}
	\label{fig:seq-diag-leader-sw-failure}
\end{figure}

The last situation in Figure~\ref{fig:seq-diag-candidate-failure} represents a failure of the candidate leader. When the leader finish the crossing, everyone wait a timeout $T$ for a message from the candidate. Since it is not alive, the timeout runs out, and a new election is performed.

\begin{figure}
	\centering
	\includegraphics[width=\linewidth]{sequence_diagrams/candidate_failure.pdf}
	\caption{Sequence diagram of a candidate leader failure.}
	\label{fig:seq-diag-candidate-failure}
\end{figure}

\section{Physical architecture and deployment}
The architecture is quite simple, a graphical representation is displayed in Figure~\ref{fig:physical-architecture}. Each Autonomous Vehicle (AV) is a physical node. The Environment represents the world sensed by AVs, so it is on a separate node, together with the vehicle generator. AVs can ask the environment for information, and they can communicate with their neighbors \footnote{For a definition of ``neighbors'', see in Chapter~\ref{ch:analysis}, in assumptions section. Where the message delivery assumption is described .}.

\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{physical_architecture.pdf}
	\caption{Physical architecture: Environment, Generator, and Autonomous Vehicles (AV).}
	\label{fig:physical-architecture}
\end{figure}


\chapter{Implementation}
The project is developed in \href{https://www.erlang.org/}{Erlang}.

\section{Getting Started}
\subsection{Project Structure}
\subsection{Hands On}

\section{Development Details}

\subsection{Intersection Coordination}

\subsection{Vehicle Generator}


\chapter{Validation}
The validation part consisted in three main phases. First of all the project was tested with few vehicles generated singularly into different shells, with Erlang nodes created on local machine. After the initial validation, simulating peculiar situation manually (software and mechanical failures, vehicles arrival at specific times, \dots), the software has undergone numerous tests with the help of the vehicle generator described in the previous chapter, even this with Erlang nodes on local machine. Finally, exploiting Docker facilities, we tested the project even in distributed containers on different hosts in a virtual network.

The project has been tested on Fedora 30 with Erlang/OTP 21, and on Ubuntu 18.04 LTS with Erlang/OTP 22.

After careful planning and developing, and after all these tests phases, we are confident of providing a reliable and sound solution. In next sections is described how to reproduce the tests.

\section{Simple Tests}

\section{Vehicle Generator}

\section{Docker}

\chapter{Conclusions}
The proposed solution focuses on a very simplified version of what a real solution could be. In particular the aim is to produce a core solution which satisfies the requirements but that also does not contain more than necessary assumptions, and in particular that does not rely on non realistic ideas that can lead future development to a blind spot.

If the core simplified part will be easily developed and validated, then some advancement can be pursued, for example:
\begin{itemize}
	\item Add vehicles with priorities, e.g. emergency vehicles;
	\item Dynamically modify paths inside the crossroad if some position becomes unavailable;
	\item Let more than one vehicle per time cross the intersection, maybe with an interface to a planner in order to find the best route (exploiting epistemic planning could be an interesting option).
\end{itemize}

\section{Partial implementation and future work}

\end{document}